# **Project Name**

----------
**Software Agent**

# **Table of contents**
--------------


1. [Authors](#authors)
2. [Introduction](#introduction)
3. [Project Files](#project-files)
4. [Tools](#tools)
5. [Compile](#compile)
	* [Maven Commands](#maven-commands)
6.  [Run](#run)
    * [Java Commands](#java-commands)
7. [Implementation](#implementation)
	1. [main](#main)
		* [Part1.java](#part1java)
	2. [rest](#rest)
		* [AcceptanceRequest.java](#acceptancerequestjava)
		* [RegisterInfo.java](#registerinfojava)
		* [RegisterRequest.java](#registerrequestjava)
    3. [software_agent](#softwareagent)
		* [NmapJob.java](#nmapjobjava)
	    * [Producer.java](#producerjava)
		* [Results.java](#resultsjava)
		* [ShutDown.java](#shutdownjava)
		* [XmlResults.java](#xmlresultsjava)
	4. [threads](#threads)
		* [OneTimeJob.java](#onetimejobjava)
	    * [PeriodicJob.java](#periodicjobjava)
	    * [Sender.java](#senderjava)
 		* [Threadpool.java](#threadpooljava)
			* [BlockingQueue](#blockingqueue)
			* [ShutdownHook](#shutdownhook)
	    

# **Authors**
---------
####  [Konstantina Galouni](http://anapgit.scanlab.gr/sdi1000034)
####  [Konstantinos Giannakelos](http://anapgit.scanlab.gr/sdi1000029)

# **Introduction**
---

Στα πλαίσια του μαθήματος καλείστε να υλοποιήσετε ένα κατανεμημένο σύστημα σάρωσης δικτύων υπολογιστών.

Το Nmap (Network Mapper) είναι ένα λογισμικό ανοικτού κώδικα που έχει ως βασικό στόχο την ανίχνευση δικτυακών συσκευών/συστημάτων και τον έλεγχό τους µε διάφορους τρόπους ως προς το λογισµικό που διαθέτουν, τις παρεχόμενος υπηρεσίες και τις ανοιχτές πόρτες στις οποίες µπορούν να συνδεθούν απομακρυσμένα νόµιµοι αλλά και κακόβουλοι χρήστες.

Όπως τα περισσότερα εργαλεία, το nmap χρησιμοποιείται τόσο από hackers που προσπαθούν να εισβάλουν στα υπολογιστικά συστήματα όσο και από τους διαχειριστές συστήματος (system administrators) προκειμένου να ανακαλύψουν αδυναμίες ασφάλειας που υπάρχουν στα συστήματα που διαχειρίζονται.

Για να προστατεύσουν τα δίκτυα υπολογιστών από τις εξωτερικές κακόβουλες σαρώσεις, οι διαχειριστές συστήματος τοποθετούν σε αυτά firewalls. Έτσι προκύπτει επιπλέον φόρτος για αυτούς, διότι θα πρέπει να συνδέονται ξεχωριστά σε κάθε δίκτυο που διαχειρίζονται για να εκτελέσουν σαρώσεις. Επομένως δημιουργείται η ανάγκη για την δημιουργία ενός λογισμικού που θα εκτελείται σε εσωτερικούς κόμβους δικτύων, το οποίο θα λαμβάνει αιτήματα για σαρώσεις και θα επιστρέφει τα αποτελέσματα αυτών στον διαχειριστή.


# **Project Files**
-------------

	**main**	| 		**rest** 			|	**software_agent**	|	**threads**
	----------	|	-----------------------	|	------------------	|	----------------
	Part1.java	| 	AcceptanceRequest.java	|	 NmapJob.java		|	OneTimeJob.java
		-		| 	RegisterInfo.java		|	 Producer.java		|	PeriodicJob.java		
		- 		| 	RegisterRequest.java	|	 Results.java		|	Sender.java
		- 		| 			-				|	 ShutDown.java		|	Threadpool.java
		- 		| 			-				|	 XmlResults.java	|			
		- 		| 			-				|			-			|
		- 		| 			-				|			-			|

# **Tools**
------------------

**Development Tools:** &nbsp; Eclipse Luna 4.4 , &nbsp; Intellij 15

**Java Version:** &nbsp; 1.7 

**Operating System:** &nbsp; Linux Ubuntu 14.04

# **Compile & Run**
-------------------
### Maven Commands

	cd SA/                      # cd to working directory
	mvn clean install           # cleans, compiles and runs the project


# **Implementation**
-------------------------
Παρακάτω περιγράφεται η υλοποίηση για κάθε πηγαίο αρχείο ανα πακέτο. 



### ***main***
--------------------
#### **Part1.java**

Η κλάση **Part1** είναι η βασική κλάση του προγράμματος η οποία περιλαμβάνει τη συνάρτηση main ,από όπου και ξεκινά η εκτέλεση του 
προγράμματος. Στη συνάρτηση main ο Software Agent εγγράφεται αρχικά ως client στον Aggregator Manager και έπειτα ελέγχει εάν έχει γίνει αποδεκτός.
Ακόμα, η δημιουργία του ShutDown (υπέυθυνη κλάση για τον ομαλό τερματισμό) και του Threadpool γίνεται στη συνάρτηση main, και την απαραίτητη πληροφορία τη βλέπει η κλάση Producer και τα υπόλοιπα νήματα μέσω ορισμάτων στους constructors τους. 
Τέλος, η συνάρτηση main είναι υπεύθυνη να διαβάσει από το αρχείο “property.dat” τυχόν ακέραιο αριθμό που αντιστοιχεί στον αριθμό των OneTimeJob νημάτων που δημιουργεί η κλάση Threadpool. Στην περίπτωση που δε δοθεί αυτός ο αριθμός υπολογίζεται ψευδοτυχαία.

### ***rest***
--------------------
#### **AcceptanceRequest.java**

Η κλάση **AcceptanceRequest** ελέγχει περιοδικά εάν ο Aggregator Manager δέχτηκε ή απέρριψε το αίτημα του Software Agent, αφού ο τελευταίος έχει προηγουμένως εγγραφεί. Στην περίπτωση που έγινε δεκτός (κωδικός 202), συνεχίζει τη λειτουργία του ζητώντας nmap jobs. Εάν απορριφθεί (κωδικός 101), αποστέλλει ξανά τις πληροφορίες και το αίτημα εγγραφής, ενώ όταν λαμβάνει ουδέτερη (κωδικός 102) ή καθόλου απάντηση, συνεχίζει τον έλεγχο περιοδικά.

<br><br><br>

Η επικοινωνία μεταξύ Software Agent και Aggregator Manager πραγματοποιείται μέσω των Jersey RESTful Web Services που βασίζονται στη λογική client-server. Στην περίπτωση αυτή, ο client είναι ο Software Agent και ο server είναι ο Aggregator Manager. Συνεπώς, ο Aggregator Manager καθορίζει τις θύρες και τα μονοπάτια στα οποία δέχεται τα ξεχωριστά αιτήματα από τους clients και θεωρούμε ότι και ο εκάστοτε πελάτης γνωρίζει και αναφέρεται ρητά στο σωστό URI.

------------------

#### **RegisterInfo.java**

Σε αυτήν την κλάση υπάρχουν οι πληροφορίες που απαιτούνται για τη δημιουργία του hashKey και την εγγραφή του Software Agent στον Aggregator Manager.
Το hostname, καθώς και οι ip και mac διευθύνσεις βρίσκονται μέσω των κατάλληλων βιβλιοθηκών, ενώ οι os version και nmap version μέσω κλήσης της εντολής nmap (nmap -V). Το hashKey είναι συνδυασμός όλων των παραπάνω πληροφοριών.

------------------

#### **RegisterRequest.java**

Η κλάση **RegisterRequest** είναι υπεύθυνη για την αποστολή των απαραίτητων στοιχείων στον Aggregator Manager μέχρι να εγγραφεί ο Software Agent. Το μήνυμα αποστολής γίνεται σε μορφή json string, η οποία διαμορφώνεται μετατρέποντας το κατάλληλο στιγμιότυπο της κλάσης RegisterInfo σε Gson μέσω του GsonBuilder, το οποίο με τη σειρά του γίνεται String με τη βοήθεια της μεθόδου toJson. Όταν η εγγραφή ολοκληρωθεί, ο AM επιστρέφει τον κωδικό 202. 


### ***software_agent***
--------------------

#### **NmapJob.java**

Η κλάση **NmapJob** κρατάει και διαχειρίζεται τις πληροφορίες των jobs που διαβάζονται από το αρχείο στην κλάση Producer. OneTimeJob: Η κλάση OneTimeJob είναι η υλοποίηση των OneTimeJob νημάτων, καθένα από τα οποία διαβάζει από την ουρά ένα job, δημιουργεί την εντολή “nmap” ολοκληρωμένα, και την εκτελεί με τη χρήση της κλάσης Runtime που διαθέτει η Java. Προτού εισάγει το αποτέλεσμα στην ουρά των αποτελεσμάτων, από την οποία αντλεί η κλάση Sender, περιμένει να ολοκληρωθεί η εκτέλεση της εντολής. Ως προς την κλάση Runtime, ισχύει πως κάθε εφαρμογή Java έχει ένα μόνο στιγμιότυπο της κλάσης Runtime που επιτρέπει στην εφαρμογή τη διεπαφή με το περιβάλλον στο οποίο η εφαρμογή εκτελείται. Το τρέχον runtime περιβάλλον μπορεί να αποκτηθεί μέσω της μεθόδου getRuntime. Η μέθοδος exec, εκτελεί σε ξεχωριστή διεργασία την εντολή που δέχεται ως όρισμα και επιστρέφει μία νέα διεργασία.

------------------

#### **Producer.java**

Η κλάση **Producer** είναι υπεύθυνη να ζητήσει από τον Aggregator Manager τα jobs και να τα κατανείμει. Συγκεκριμένα, εάν το job που πήρε είναι περιοδικό, εκκινεί ένα νέο περιοδικό νήμα στο οποίο αναθέτει το job αυτό, ενώ στην περίπτωση που το αντίστοιχο flag είναι false (μη περιοδικό job) εισάγει το job αυτό στη διαμοιραζόμενη ουρά του threadpool, από την οποία εξάγουν τα OneTimeJob νήματα.
Επιπλέον, υπάρχει η πιθανότητα το job που έλαβε να είναι ένα περιοδικό job προς διαγραφή, οπότε διακόπτει το αντίστοιχο νήμα, ή ένα job που απαιτεί τον τερματισμό της εφαρμογής, άρα δημιουργεί ένα νέο νήμα που εκτελεί την εντολή System.exit(0).
Δεδομένου ότι τα αποτελέσματα πρέπει να είναι σε μορφή XML, εξασφαλίζεται ότι η εντολή “nmap” περιλαμβάνει το flag “-oX -”.

----------------------

#### **Results.java**
Η κλάση **Results** περιέχει το nmapJobId, όπως έχει ανατεθεί στο αντίστοιχο νήμα (OneTime ή Periodic), καθώς και τον BufferedReader που κρατά τα αποτελέσματα της εκτέλεσης της εκάστοτε εντολής nmap. Η κλάση αυτή αποστέλλεται από κάθε νήμα που εκτελεί jobs, αμέσως μόλις ολοκληρωθεί το job που έχει αναλάβει, στο νήμα του Sender.

----------------------

#### **ShutDown.java**
Η κλάση **ShutDown** είναι υπεύθυνη για το τερματισμό των νημάτων με χρήση του **ctrl + C**. Συγκεκριμένα, περιέχει ενα **shutdownhook** το οποίο “πιάνει” το σήμα και καλεί τη μέθοδο cleanup για τον ομαλό τερματισμό όλων των νημάτων μέσω **interrupt και join**.
Πεδίο της κλάσης είναι μία λίστα από **Thread** για να επιτυγχάνεται ο ομαλός τερματισμός των νημάτων (**cleanup**).

----------------------

#### **XmlResults.java**
Η κλάση **XmlResults** περιέχει το nmapJobId που έλαβε ο Sender, όπως έχει ανατεθεί στο αντίστοιχο νήμα (OneTime ή Periodic), καθώς και τα αποτελέσματα που διάβασε από τον BufferedReader που έλαβε ο Sender σε μορφή String. Οι πληροφορίες της κλάσης αποστέλλονται (αφού μετατραπούν σε json string) στον Aggregator Manager, ώστε να αποθηκευτούν, να υποστούν επεξεργασία και τελικά να προβληθούν σε φιλική προς το χρήστη μορφή.


### ***threads***
--------------------

#### **Threadpool.java**
 Η κλάση **Threadpool** είναι υπεύθυνη για τη δημιουργία των **OneTimeJob** νημάτων, του Sender νήματος και των διαμοιραζόμενων ουρών.

Η υλοποίηση του threadpool αποτελείται από :

1. μία διαμοιραζόμενη ουρά (**queue**) για την αποθήκευση των **NmapJob** από τo **producer** νήμα και την εξαγωγή τους από τα consumer νήματα (**OnetimeJob**).

2. μία διαμοιραζόμενη ουρά (**results**) για την αποθήκευση των αποτελεσμάτων των **NmapJob** ύστερα από την εκτέλεση τους.

<br>

##### **BlockingQueue**
Για τις διαμοιραζόμενες ουρές έχει γίνει χρήση των πακέτων :

<br>

 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; `java.util.concurrent.BlockingQueue;`
 
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; `java.util.concurrent.LinkedBlockingQueue;`


<br>

Η συγκεκριμένη δομή υποστηρίζει το μοντέλο **producer-consumer** σε ένα πολυνηματικό περιβάλλον. Παρέχει **εσωτερικά locks** για το συγχρονισμό των νημάτων και εντολές που είναι **thread-safe**. Πιό συγκεκριμένα :


**put()**: Η μέθοδος προσθέτει στοιχεία στην ουρά και μπλοκάρει το νήμα εαν συναντήσει τη δομή γεμάτη. Το νήμα ξεμπλοκάρει και συνεχίζει κανονικά όταν υπάρξει διαθέσιμος χώρος ξανά στην ουρά. 
<br><br>
**take()**: Η μέθοδος αφαιρεί το πρώτο στοιχείο από την ουρά (εφόσον αυτή έχει στοιχεία) και μπλοκάρει το νήμα που την καλεί εαν η ουρα είναι άδεια. Επίσης η μέθοδος είναι thread-safe, δηλαδή ένα νήμα που χρησιμοποιεί τη μέθοδο αυτή, μπλοκάρει όλα τα υπόλοιπα νήματα που προσπαθούν να την καλέσουν για τη διάρκεια εκτέλεσης της. Με αυτόν τον τρόπο αποφεύγονται τυχόν **conflicts** και **race conditions** μεταξύ των νημάτων.
<br><br><br>
Για περισσότερες πληροφορίες μπορείτε να μεταβείτε στον εξής σύνδεσμο:

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;https://docs.orlace.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html

----------------------

#### **OneTimeJob.java**

Η κλάση **OneTimeJob** είναι η υλοποίηση των OneTimeJob νημάτων, καθένα από τα οποία διαβάζει από την ουρά ένα job, δημιουργεί την εντολή “**nmap**” ολοκληρωμένα, και την εκτελεί με τη χρήση της κλάσης **Runtime** που διαθέτει η **Java**. Προτού εισάγει το αποτέλεσμα στην ουρά των αποτελεσμάτων, από την οποία αντλεί η κλάση **Sender**, περιμένει να ολοκληρωθεί η εκτέλεση της εντολής. Ως προς την κλάση **Runtime**, ισχύει πως κάθε εφαρμογή Java έχει ένα μόνο στιγμιότυπο της κλάσης **Runtime** που επιτρέπει στην εφαρμογή τη διεπαφή με το περιβάλλον στο οποίο η εφαρμογή εκτελείται. Το τρέχον runtime περιβάλλον μπορεί να αποκτηθεί μέσω της μεθόδου **getRuntime**. Η μέθοδος **exec**, εκτελεί σε ξεχωριστή διεργασία την εντολή που δέχεται ως όρισμα και επιστρέφει μία νέα διεργασία.

-------------------------------------
#### **PeriodicJob.java**

Η κλάση **PeriodicJob** είναι η υλοποίηση των περιοδικών νημάτων, καθένα από τα οποία αναλαμβάνει να εκτελεί περιοδικά το job που του ανατέθηκε. Συνεπώς, όπως και τα OneTimeJob νήματα, εκτελεί την εντολή “nmap” με τη χρήση της κλάσης Runtime που διαθέτει η Java. Ομοίως, προτού εισάγει το αποτέλεσμα στην ουρά των αποτελεσμάτων, από την οποία αντλεί η κλάση Sender, περιμένει να ολοκληρωθεί η εκτέλεση της εντολής. Έπειτα εισέρχεται σε non-runnable κατάσταση (μέσω sleep) για όσα δευτερόλεπτα αναφέρονται στο αρχείο και μόλις “ξυπνήσει” επαναλαμβάνει την ίδια διαδικασία.

----------------------
#### **Sender.java** 

Η κλάση **Sender** είναι η υλοποίηση του Sender νήματος, το οποίο διαβάζει περιοδικά από την ουρά αποτελεσμάτων τα διαθέσιμα ολοκληρωμένα αποτελέσματα και τα στέλνει σε μορφή json string στον Aggregator Manager. Όταν δεν υπάρχουν άλλα αποτελέσματα, εισέρχεται σε non-runnable κατάσταση (μέσω sleep) για ψευδοτυχαία δευτερόλεπτα και μόλις “ξυπνήσει” επαναλαμβάνει την ίδια διαδικασία. Όλα τα νήματα συνεχίζουν την εκτέλεσή τους με βάση τη συνθήκη:

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;`while (!Thread.currentThread().isInterrupted())`

η οποία επιτρέπει στα νήματα να εκτελούνται συνεχώς μέχρις ότου να δεχθούν ένα σήμα που να τα διακόπτει. Το σήμα αυτό το λαμβάνουν μέσω της συνάρτησης **cleanup**, που διακόπτει όλα τα νήματα και το διαχειρίζονται με τη βοήθεια του catch **InterruptedException**. Με αυτόν τον τρόπο, εξασφαλίζεται ο ομαλός τερματισμός όλων των νημάτων, ενώ θέτοντας τις δομές σε null, και καλώντας τον garbage collector, αποδεσμεύονται όλα άμεσα.

